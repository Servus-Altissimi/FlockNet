use super::MetricsSnapshot;
use serde::{Deserialize, Serialize};
use std::fs::File;
use std::io::Write;
use std::path::Path;
use anyhow::Result;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisReport {
    pub strategy_name: String,
    pub avg_throughput_mbps: f64,
    pub avg_latency_ms: f64,
    pub packet_loss_rate: f64,
    pub peak_queue_length: usize,
    pub avg_queue_length: f64,
    pub jitter_ms: f64,
}

pub fn analyze(snapshots: &[MetricsSnapshot], strategy_name: &str) -> AnalysisReport {
    if snapshots.is_empty() {
        return AnalysisReport {
            strategy_name: strategy_name.to_string(),
            avg_throughput_mbps: 0.0,
            avg_latency_ms: 0.0,
            packet_loss_rate: 0.0,
            peak_queue_length: 0,
            avg_queue_length: 0.0,
            jitter_ms: 0.0,
        };
    }
    
    let avg_throughput_mbps = snapshots.iter()
        .map(|s| s.throughput_bps / 1_000_000.0)
        .sum::<f64>() / snapshots.len() as f64;
    
    let avg_latency_ms = snapshots.iter()
        .map(|s| s.avg_latency_ms)
        .sum::<f64>() / snapshots.len() as f64;
    
    let packet_loss_rate = snapshots.last()
        .map(|s| s.packet_loss_rate)
        .unwrap_or(0.0);
    
    let peak_queue_length = snapshots.iter()
        .map(|s| s.queue_length)
        .max()
        .unwrap_or(0);
    
    let avg_queue_length = snapshots.iter()
        .map(|s| s.queue_length as f64)
        .sum::<f64>() / snapshots.len() as f64;
    
    let latencies: Vec<f64> = snapshots.iter().map(|s| s.avg_latency_ms).collect();
    let jitter_ms = if latencies.len() > 1 {
        let mean = avg_latency_ms;
        let variance = latencies.iter()
            .map(|l| (l - mean).powi(2))
            .sum::<f64>() / latencies.len() as f64;
        variance.sqrt()
    } else {
        0.0
    };
    
    AnalysisReport {
        strategy_name: strategy_name.to_string(),
        avg_throughput_mbps,
        avg_latency_ms,
        packet_loss_rate,
        peak_queue_length,
        avg_queue_length,
        jitter_ms,
    }
}

pub fn export_latex_table(reports: &[AnalysisReport], output_path: impl AsRef<Path>) -> Result<()> {
    let mut file = File::create(output_path)?;
    
    writeln!(file, "% Generated by FlockNet")?;
    writeln!(file, "% Timestamp: {}\n", chrono::Local::now().format("%Y-%m-%d %H:%M:%S"))?;
    
    writeln!(file, "\\begin{{table}}[H]")?;
    writeln!(file, "\t\\centering")?;
    writeln!(file, "\t\\caption{{Vergelijking van bufferstrategieën tijdens piekverkeer}}")?;
    writeln!(file, "\t\\label{{tab:strategy_comparison}}")?;
    writeln!(file, "\t\\begin{{tabular}}{{|l|r|r|r|r|r|r|}}")?;
    writeln!(file, "\t\t\\hline")?;
    writeln!(file, "\t\t\\textbf{{Strategie}} & \\textbf{{Doorvoer}} & \\textbf{{Latentie}} & \\textbf{{Pakketverlies}} & \\textbf{{Gem. Wachtrij}} & \\textbf{{Piek Wachtrij}} & \\textbf{{Jitter}} \\\\")?;
    writeln!(file, "\t\t& (Mbps) & (ms) & (\\%) & (pakketten) & (pakketten) & (ms) \\\\")?;
    writeln!(file, "\t\t\\hline")?;
    
    for report in reports {
        writeln!(
            file,
            "\t\t{} & {:.2} & {:.2} & {:.2} & {:.1} & {} & {:.2} \\\\",
            escape_latex(&report.strategy_name),
            report.avg_throughput_mbps,
            report.avg_latency_ms,
            report.packet_loss_rate * 100.0,
            report.avg_queue_length,
            report.peak_queue_length,
            report.jitter_ms,
        )?;
    }
    
    writeln!(file, "\t\t\\hline")?;
    writeln!(file, "\t\\end{{tabular}}")?;
    writeln!(file, "\\end{{table}}")?;
    
    Ok(())
}

pub fn export_latex_detailed(reports: &[AnalysisReport], output_path: impl AsRef<Path>) -> Result<()> {
    let mut file = File::create(output_path)?;
    
    writeln!(file, "% Generated by FlockNet")?;
    writeln!(file, "% Detailed analysis results\n")?;
    
    writeln!(file, "\\section{{Gedetailleerde Resultaten}}")?;
    writeln!(file)?;
    
    let best_throughput = reports.iter()
        .max_by(|a, b| a.avg_throughput_mbps.partial_cmp(&b.avg_throughput_mbps).unwrap());
    let best_latency = reports.iter()
        .min_by(|a, b| a.avg_latency_ms.partial_cmp(&b.avg_latency_ms).unwrap());
    let best_loss = reports.iter()
        .min_by(|a, b| a.packet_loss_rate.partial_cmp(&b.packet_loss_rate).unwrap());
    
    writeln!(file, "\\subsection{{Beste Prestaties}}")?;
    writeln!(file)?;
    
    if let Some(r) = best_throughput {
        writeln!(file, "\\textbf{{Hoogste Doorvoer:}} {} behaalde een gemiddelde doorvoer van {:.2} Mbps, wat de hoogste is van alle geteste strategieën.",
            escape_latex(&r.strategy_name), r.avg_throughput_mbps)?;
        writeln!(file)?;
    }
    
    if let Some(r) = best_latency {
        writeln!(file, "\\textbf{{Laagste Latentie:}} {} had de laagste gemiddelde latentie van {:.2} ms, wat zorgt voor responsievere communicatie in de zwerm.",
            escape_latex(&r.strategy_name), r.avg_latency_ms)?;
        writeln!(file)?;
    }
    
    if let Some(r) = best_loss {
        writeln!(file, "\\textbf{{Laagste Pakketverlies:}} {} vertoonde het laagste pakketverlies met slechts {:.2}\\%, wat de betrouwbaarheid van datatransmissie maximaliseert.",
            escape_latex(&r.strategy_name), r.packet_loss_rate * 100.0)?;
        writeln!(file)?;
    }
    
    writeln!(file, "\\subsection{{Strategie-specifieke Analyse}}")?;
    writeln!(file)?;
    
    for report in reports {
        writeln!(file, "\\subsubsection{{{}}}", escape_latex(&report.strategy_name))?;
        writeln!(file)?;
        writeln!(file, "\\begin{{itemize}}")?;
        writeln!(file, "\t\\item Gemiddelde doorvoer: {:.2} Mbps", report.avg_throughput_mbps)?;
        writeln!(file, "\t\\item Gemiddelde latentie: {:.2} ms", report.avg_latency_ms)?;
        writeln!(file, "\t\\item Pakketverlies: {:.2}\\%", report.packet_loss_rate * 100.0)?;
        writeln!(file, "\t\\item Gemiddelde wachtrijlengte: {:.1} pakketten", report.avg_queue_length)?;
        writeln!(file, "\t\\item Piek wachtrijlengte: {} pakketten", report.peak_queue_length)?;
        writeln!(file, "\t\\item Jitter: {:.2} ms", report.jitter_ms)?;
        writeln!(file, "\\end{{itemize}}")?;
        writeln!(file)?;
    }
    
    Ok(())
}

pub fn export_latex_plot_data(snapshots: &[MetricsSnapshot], output_path: impl AsRef<Path>) -> Result<()> {
    let mut file = File::create(output_path)?;
    
    writeln!(file, "% Time-series data for pgfplots")?;
    writeln!(file, "% Format: time throughput latency queue_length packet_loss\n")?;
    
    for snapshot in snapshots {
        writeln!(
            file,
            "{:.2} {:.2} {:.2} {} {:.4}",
            snapshot.timestamp,
            snapshot.throughput_bps / 1_000_000.0,
            snapshot.avg_latency_ms,
            snapshot.queue_length,
            snapshot.packet_loss_rate,
        )?;
    }
    
    Ok(())
}

pub fn export_latex_figure(
    reports: &[AnalysisReport],
    output_path: impl AsRef<Path>,
    caption: &str,
    label: &str,
) -> Result<()> {
    let mut file = File::create(output_path)?;
    
    writeln!(file, "\\begin{{figure}}[H]")?;
    writeln!(file, "\t\\centering")?;
    writeln!(file, "\t\\begin{{tikzpicture}}")?;
    writeln!(file, "\t\t\\begin{{axis}}[")?;
    writeln!(file, "\t\t\tybar,")?;
    writeln!(file, "\t\t\tbar width=15pt,")?;
    writeln!(file, "\t\t\tylabel={{Gemiddelde Doorvoer (Mbps)}},")?;
    writeln!(file, "\t\t\txlabel={{Strategie}},")?;
    writeln!(file, "\t\t\txticklabel style={{rotate=45, anchor=east}},")?;
    writeln!(file, "\t\t\tsymbolic x coords={{{}}},", 
        reports.iter().map(|r| escape_latex(&r.strategy_name)).collect::<Vec<_>>().join(","))?;
    writeln!(file, "\t\t\tenlarge x limits=0.15,")?;
    writeln!(file, "\t\t\tnodes near coords,")?;
    writeln!(file, "\t\t\tnodes near coords align={{vertical}},")?;
    writeln!(file, "\t\t]")?;
    
    writeln!(file, "\t\t\\addplot coordinates {{")?;
    for report in reports {
        writeln!(file, "\t\t\t({}, {:.2})", 
            escape_latex(&report.strategy_name), 
            report.avg_throughput_mbps)?;
    }
    writeln!(file, "\t\t}};")?;
    
    writeln!(file, "\t\t\\end{{axis}}")?;
    writeln!(file, "\t\\end{{tikzpicture}}")?;
    writeln!(file, "\t\\caption{{{}}}", caption)?;
    writeln!(file, "\t\\label{{{}}}", label)?;
    writeln!(file, "\\end{{figure}}")?;
    
    Ok(())
}

fn escape_latex(s: &str) -> String {
    s.replace('_', "\\_")
        .replace('%', "\\%")
        .replace(',', "{,}")  // Fixed: was "\\$", should preserve commas in a group        
        .replace('&', "\\&")
        .replace('#', "\\#")
        .replace('{', "\\{")
        .replace('}', "\\}")
}
